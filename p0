#!/usr/bin/env perl

use strict;
use warnings;

package Pegleg;

use Any::Moose;

has _rule_map => qw/ is ro isa HashRef lazy_build 1 /;
sub _build__rule_map { {} }
sub rule { return shift->_rule_map }

sub setup {
    my $self = shift;
    while( @_ ) {
        my $name = shift;
        my $body = shift;
        $self->rule->{$name} = $body;
    }
}


sub debug {
    warn @_, "\n";
}

sub parse {
    my $self = shift;
    my $input = shift;
    my $rule = shift;

    my $parse = Pegleg::Parse->new( input => $input );
    my $state = Pegleg::State->new( position => 0 );

    return $self->_parse( $parse, $state, $rule ); 
}

sub _parse {
    my $self = shift;
    my $parse = shift;
    my $state = shift;
    my $rule = shift;

    return if $state->position == $parse->length;

    debug "input => ", $parse->input, " @ ", $state->position, " [", $parse->length, "]";
    debug "rule => $rule"; # (", ref $rule, ")";

    if ( ref $rule eq 'ARRAY' ) {
        my $state = $state;
        my( @result, $result );
        for my $_ (@$rule) {
            return unless ( $result, $state ) = $self->_parse( $parse, $state, $_ );
            push @result, $result;
        }
        return ( \@result, $state );
    }
    elsif ( ref $rule eq '' ) {
        return $self->_parse( $parse, $state, $self->rule->{$rule} );
    }
    elsif ( ref $rule eq 'Regexp' ) {
        my $input = $parse->input( $state->position );
        return unless $input =~ m/$rule/;
        my $matched = substr( $input, $-[0], $+[0]-$-[0] );
        debug "matched => $matched";
        $state = Pegleg::State->new( position => $state->position + $+[0] );
        return ( $matched, $state );
    }

    die "Err";
}

package Pegleg::Rule;

use Any::Moose;

package Pegleg::Parse;

use Any::Moose;

has length => qw/ is ro isa Int lazy_build 1 /;
sub _build_length { length shift->_input }

has _input => qw/ is rw isa Str required 1 init_arg input /;
has _input_cache => qw/ is ro isa HashRef lazy_build 1 /;
sub _build__input_cache { {} }

sub input {
    my $self = shift;
    return $self->_input unless @_;
    my $position = shift;
    return $self->_input_cache->{$position} ||= do {
        my $input = $self->_input;
        substr $input, $position;
    };
}

package Pegleg::State;

use Any::Moose;

has position => qw/ is ro required 1 /;

package main;

use Test::Most;

plan qw/ no_plan /;

ok( 1 );

sub parser {
    my $parser = Pegleg->new;
    $parser->setup( @_ );
    return $parser;
}

my $parser = parser
    literal => qr/^\d*\.\d*|\d+|".*?"/,
    operator => qr/^\+|\-|\*|\/|\=\=/,
    operation => [qw/ literal operator expression /],
    expression => [qw/ operation /],
;

$parser->parse( '1+2-3', 'expression' );
